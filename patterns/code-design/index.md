[Software Architecture](../..) > [Patterns](..) > Code Design

---

All of these patterns pertain to the structuring or organisation of the software units internally within an larger software component. The software component may be a standalone application, or it may be an integral part of a larger system, but either way the component is in some aspect coherent and whole in and of itself. The specific interpretation of ‘software unit’ depends on the context, for example, in object oriented languages a software unit might be defined as a class, but in any case the term implies atomicity. All of these patterns are concerned with defining boundaries within the component and a scheme for placing its software units within them. The indivisible nature of a software unit means it necessarily must be placed one side of a boundary or the other.

- The [layered](layered) architectural pattern aids comprehensibility and discoverability by organising a system’s code into distinct layers, with separate responsibilities assigned to each layer. There are usually rules governing how the layers may talk to each other: for example, the UI layer may talk to the service layer, but not directly to the persistence layer.
- The [hexagonal](hexagonal) pattern (also known as “ports and adapters”) separates core logic from external concerns (such as user interfaces and databases) by exposing “ports” (interfaces) on the core component that define the required protocols separately for each externality. The externalities are connected to the component by “adapters” which plug into the ports to provide the required functionality while also isolating the component from the external details. A hexagonal design treats all externalities on an equal footing, unlike a layered design which by its top-to-bottom orientation implies a hierarchy. The hexagon shape was chosen to make it easy to represent the ports on a diagram, recognising that components often interface with more than two other components (but seldom more than six).
- A [plugin](plugin) architecture delegates certain system responsibilities to interchangeable components that are “plugged in” to the host system via a common API that is defined by the host system. Thus the host system has no dependency on its plugins: the plugins can be developed entirely separately by different people, and they may extend the host system’s functionality in ways not anticipated by its creators. The host system and its plugins run as a single process, but the plugins may be linked either statically, which requires the host system to be recompiled, or dynamically, which does not.
