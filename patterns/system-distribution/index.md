[Software Architecture](../..) > [Patterns](..) > System Distribution

---

These patterns describe methods of organising systems that are distributed across multiple computers.
- A [monolith](system-distribution/monolith) is the degenerate case of distributed systems, being not distributed at all. Monolithic systems typically run in a single process, and they are built and deployed as a single unit.
- The [client-server](system-distribution/client-server) model separates the application into multiple rich (or ‘thick’) user interface components (the clients) each in two-way communication with a single common backend (the server). Client-server designs fell out of favour when web applications became popular but have returned in the form of mobile apps, although these designs are not usually referred to as such.
- The [n-tier](system-distribution/n-tier) architecture separates an application into multiple layers, but unlike the layered architecture pattern, each layer runs on a separate machine. An example would be a web application comprising a web server handling the HTTP requests, an application server where the business logic resides, and a database where the data is persisted.
- A [service-oriented](system-distribution/service-oriented-architecture) architecture separates a system into services, which are independent, headless, continuously running processes that handle requests. Services may communicate by calling each other directly or indirectly by passing messages via queues. Microservices are also in this category, but with particular emphasis placed on independent deployability; additionally, a microservice architecture is as much about the team structure and organisation (human interactions) as it is about technical design.
- A [micro frontend](web-applications/micro-frontend) is a reusable web UI component that is designed to be incorporated into a web application. Implementation wise it is very similar to the microservice concept, the main difference being that a micro frontend presents a UI while a microservice does not. As with a microservice, the rationale for creating a micro frontend is independent deployability and scalability.
- A [shared-nothing](system-distribution/shared-nothing) architecture allows large jobs to be farmed out to a cluster of nodes, each of which receives a ‘shard’ (portion) of the work. For this pattern to work, it must be possible for each shard to be processed in isolation from all the others, so that the nodes have no need to communicate with each other.
- A [peer-to-peer](system-distribution/peer-to-peer) architecture is composed of multiple nodes that communicate with each other and self-organise without any central orchestration. Such a system is highly resilient because there is no single point of failure; individual nodes may fail but the whole will continue to operate.
- [Pipes and filters](system-distribution/pipes-and-filters) describes a system composed of reusable components that individually perform simple jobs, and are designed to accept input and/or emit output such that they can be chained together to accomplish far more complicated tasks.
- The [actor model](system-distribution/actor-model) for concurrency describes a way of optimising a system for high reliability. Actors are concurrent processes that communicate by passing messages to each other. Each actor receives its messages on a dedicated queue from which it consumes the messages one at a time. An individual actor is thus single-threaded while they run concurrently with other actors. The actors are monitored by a supervisor which detects failed actors and restarts them automatically, which is where the resilience comes from. Although the actor model was not originally intended for distributed systems, it certainly can be applied to them: the actor model could certainly be combined with a microservice architecture.
